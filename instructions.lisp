(in-package :vm0)

(defvm-instructions
  (:pop (safe-pop))
  (:push (safe-push (cadr instruction)))
  (:pick (pop-1 index (safe-push (safe-read index))))
  (:set (pop-2 a index (safe-write index a)))
  (:dup (safe-push (safe-read 0 :mode :top-down)))
  (:over (safe-push (safe-read 1 :mode :top-down)))
  (:roll (pop-1 depth (let ((new-tos (safe-read depth :mode :top-down)))
                        (shift-down depth)
                        (safe-write 0 new-tos :mode :top-down))))
  (:not (pop-1 a (safe-push (if (zerop a) 1 0))))
  (:add (pop-2 a b (safe-push (+ a b))))
  (:sub (pop-2 a b (safe-push (- a b))))
  (:mul (pop-2 a b (safe-push (* a b))))
  (:div (pop-2 a b (if (zerop b)
                       (trap :divide-by-zero)
                       (safe-push (truncate a b)))))
  (:mod (pop-2 a b (if (zerop b)
                       (trap :divide-by-zero)
                       (safe-push (nth-value 1 (truncate a b))))))
  (:eq (pop-2 a b (safe-push (if (= a b) 1 0))))
  (:lt (pop-2 a b (safe-push (if (< a b) 1 0))))
  (:gt (pop-2 a b (safe-push (if (> a b) 1 0))))
  (:jmp (jump (cadr instruction)))
  (:jz (pop-1 a (when (zerop a) (jump (cadr instruction)))))
  (:jnz (pop-1 a (unless (zerop a) (jump (cadr instruction)))))
  (:call (let ((%sp sp))
           (safe-push fp) (safe-push pc) (setf fp %sp) (jump (cadr instruction))))
  (:ret (pop-2 %fp %pc (setf fp %fp) (jump %pc)))
  (:print (pop-1 a (format t "~A~%" a)))
  (:halt (done)))

(defvm-macros
  (:swap '((:push 1) (:roll)))
  (:rot '((:push 2) (:roll)))
  (:inc '((:push 1) (:add)))
  (:dec '((:push 1) (:sub)))
  (:lte '((:gt) (:not)))
  (:gte '((:lt) (:not)))
  ;; TODO: these macros need to be redefined when :rroll is available
  (:fn-args-1 '((:push 2) (:roll)))
  (:fn-args-2 '((:push 3) (:roll) (:push 3) (:roll)))
  (:fn-args-3 '((:push 4) (:roll) (:push 4) (:roll) (:push 4) (:roll)))
  (:retv '((:push 2) (:roll) (:push 2) (:roll) (:ret))))
