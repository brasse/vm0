(in-package :vm0)

(defvm-instructions
  (:pop (safe-pop))
  (:push (safe-push (cadr instruction)))
  (:pick (with-1 depth (safe-push (safe-read depth))))
  (:set (with-2 a depth (safe-write depth a)))
  (:roll (with-1 depth (let ((new-tos (safe-read depth)))
                         (shift-down depth)
                         (safe-write 0 new-tos))))
  (:add (with-2 a b (safe-push (+ a b))))
  (:sub (with-2 a b (safe-push (- a b))))
  (:mul (with-2 a b (safe-push (* a b))))
  (:div (with-2 a b (if (zerop b)
                        (trap :divide-by-zero)
                        (safe-push (truncate a b)))))
  (:mod (with-2 a b (if (zerop b)
                        (trap :divide-by-zero)
                        (safe-push (nth-value 1 (truncate a b))))))
  (:eq (with-2 a b (safe-push (if (= a b) 1 0))))
  (:lt (with-2 a b (safe-push (if (< a b) 1 0))))
  (:gt (with-2 a b (safe-push (if (> a b) 1 0))))
  (:jmp (jump (cadr instruction)))
  (:jz (with-1 a (when (zerop a) (jump (cadr instruction)))))
  (:jnz (with-1 a (unless (zerop a) (jump (cadr instruction)))))
  (:call (progn (safe-push pc) (jump (cadr instruction))))
  (:ret (with-1 a (jump a)))
  (:print (with-1 a (format t "~A~%" a)))
  (:halt (done)))

(defvm-macros
  (:dup '((:push 0) (:pick)))
  (:over '((:push 1) (:pick)))
  (:swap '((:push 1) (:roll)))
  (:rot '((:push 2) (:roll)))
  (:inc '((:push 1) (:add)))
  (:dec '((:push 1) (:sub))))
